# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/03_features.ipynb.

# %% auto 0
__all__ = ['project_root', 'min_width', 'min_height', 'find_min_dim', 'resize_img_to_dim', 'extract_hog_features_from_list',
           'extract_lbp_features_from_list', 'feature_fusion', 'extract_hsv_features_from_list',
           'extract_masked_hsv_features']

# %% ../notebooks/03_features.ipynb 1
import sys
import os

# Path to the project root (one level above notebooks/)
project_root = os.path.abspath("..")

# Add to Python path
sys.path.append(project_root)

import weedcrop.dataset as weedcrop_ds
import cv2
from skimage.feature import hog, local_binary_pattern

from PIL import Image

# %% ../notebooks/03_features.ipynb 5
min_width, min_height = 2000, 2000

def find_min_dim(ds):
    """
    Finds the smallest width and height in the dataset using PIL.
    """
    min_width, min_height = 2000, 2000
    for each_img in ds:
        img = Image.open(each_img[0]) # PIL - RGB/RGBA by default
        min_width = min(min_width, img.size[0])
        min_height = min(min_height, img.size[1])

    print(f"Minimum resolution: {min_width, min_height}")
    return min_width, min_height

# %% ../notebooks/03_features.ipynb 6
def resize_img_to_dim(img_file_path, width, height):
    """
    Loads image with CV2, converts to RGB, and resizes.
    """
    img_bgr = cv2.imread(img_file_path) # CV2 reads in BGR by default
    img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)
    img_resized = cv2.resize(img_rgb, (width, height))
    return img_resized

# %% ../notebooks/03_features.ipynb 9
from skimage.feature import hog
from skimage.color import rgb2gray

def extract_hog_features_from_list(X_images_rgb, y_labels):
    """
    Takes a list of pre-resized RGB images and returns HOG features.
    """
    X_hog_features = []
    
    for img_rgb in X_images_rgb:
        # 1. Convert our standard RGB to Gray using skimage
        # This ensures the same weights are used as in your other skimage functions
        img_gray = rgb2gray(img_rgb)

        # 2. Extract HOG
        hog_features = hog(
            img_gray,
            orientations=9,
            pixels_per_cell=(8, 8),
            cells_per_block=(2, 2),
            visualize=False
        )

        X_hog_features.append(hog_features)
        
    return np.array(X_hog_features), np.array(y_labels)

# %% ../notebooks/03_features.ipynb 15
from skimage import feature, color
import numpy as np

def extract_lbp_features_from_list(X_images_rgb, y_labels):
    """
    Standardized LBP extraction using pre-resized RGB images.
    """
    X_lbp_features = []
    
    for img_rgb in X_images_rgb:
        # 1. Convert our standard RGB to Gray
        # Using skimage.color ensures consistency across the whole project
        img_gray = color.rgb2gray(img_rgb)

        # 2. Extract LBP
        lbp = feature.local_binary_pattern(img_gray, P=8, R=1, method='uniform')
        
        # 3. Create Histogram (10 bins for P=8 uniform)
        lbp_hist, _ = np.histogram(lbp.ravel(), bins=np.arange(0, 11), density=True)

        X_lbp_features.append(lbp_hist)
        
    return np.array(X_lbp_features), np.array(y_labels)

# %% ../notebooks/03_features.ipynb 19
def feature_fusion(super_matrix=None, feature_list=[]):
    """ Fuses a list of features into a super-matrix. """
    
    new_features = [np.array(f) for f in feature_list]
    
    if super_matrix is None:
        super_matrix = np.hstack([ np.array(f) for f in feature_list ])
        
    else:
        super_matrix = np.hstack([super_matrix] + new_features)
        
    return super_matrix

# %% ../notebooks/03_features.ipynb 21
from skimage.color import rgb2hsv
import numpy as np

def extract_hsv_features_from_list(X_images_resized, bins=16):
    """
    Extracts H, S, and V histograms from the pre-resized RGB image list.
    """
    X_hsv_features = []
    
    for img_rgb in X_images_resized:
        # Convert to HSV (skimage expects RGB, values 0-1)
        hsv_img = rgb2hsv(img_rgb)
        
        # Split channels
        h_chan = hsv_img[:, :, 0]
        s_chan = hsv_img[:, :, 1]
        v_chan = hsv_img[:, :, 2]

        # Calculate histograms for each channel
        # We use density=True to normalize the vectors
        h_hist, _ = np.histogram(h_chan, bins=bins, range=(0, 1), density=True)
        s_hist, _ = np.histogram(s_chan, bins=bins, range=(0, 1), density=True)
        v_hist, _ = np.histogram(v_chan, bins=bins, range=(0, 1), density=True)

        # Combine H, S, and V into one feature vector for this image
        hsv_vector = np.concatenate([h_hist, s_hist, v_hist]) # Flat vector
        X_hsv_features.append(hsv_vector)
        
    return np.array(X_hsv_features)

# %% ../notebooks/03_features.ipynb 23
from skimage.color import rgb2hsv
import numpy as np

def extract_masked_hsv_features(X_images_resized, bins=16):
    """
    Extracts HSV histograms ONLY from pixels identified as 'Plant' 
    based on Hue and Value thresholds.
    """
    X_hsv_features = []
    
    for img_rgb in X_images_resized:
        # 1. Convert to HSV
        hsv_img = rgb2hsv(img_rgb)
        h, s, v = hsv_img[:,:,0], hsv_img[:,:,1], hsv_img[:,:,2]
        
        # 2. Apply your "Plant Discovery" Mask
        # We only look at 'Green' hues (0.2 - 0.45) and skip dark shadows (v > 0.1)
        mask = (h > 0.2) & (h < 0.45) & (v > 0.1)
        
        # 3. Extract pixels that belong to the plant
        # This collapses the 2D image into a 1D list of 'Plant' pixels
        plant_h = h[mask]
        plant_s = s[mask]
        plant_v = v[mask]

        # 4. Handle edge case: if no plant is detected, return zeros
        if len(plant_h) > 0:
            h_hist, _ = np.histogram(plant_h, bins=bins, range=(0, 1), density=True)
            s_hist, _ = np.histogram(plant_s, bins=bins, range=(0, 1), density=True)
            v_hist, _ = np.histogram(plant_v, bins=bins, range=(0, 1), density=True)
        else:
            h_hist = np.zeros(bins)
            s_hist = np.zeros(bins)
            v_hist = np.zeros(bins)

        # 5. Combine and append
        hsv_vector = np.concatenate([h_hist, s_hist, v_hist])
        X_hsv_features.append(hsv_vector)
        
    return np.array(X_hsv_features)
